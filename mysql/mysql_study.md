#MySql

## 服务器性能剖析

### 诊断间歇性问题

#### 使用SHOW GLOBAL STATUS

```
mysqladmin ext -i1 | awk '
/Queries/{q=$4-qp;qp=$4}
/Threads_connected/{tc=$4}
/Threads_running/{printf "%5d %5d %5d\n", p, tc, $4}'
```

此命令计算并输出每秒的查询数，Threads_connected和Threads_running(表示当前正在执行查询的线程数), 这三个数据的趋势对于服务器级别偶尔停顿的敏感性很高。一般发生此类问题时，根据原因的不同和应用连接数据库的方式的不同，每秒的查询数一般会下跌，而其他两个则至少有一个会出现尖刺。如果应用使用了连接池，Threads_connected没有变化，但正在执行查询的线程数明显上升，同时每秒的查询数相比正常数据有严重的下跌。
如何解析这个现象：

* 其中之一是服务器内部碰到了某种瓶颈，导致新查询在开始执行前因为需要获取老查询正在等待的锁而造成堆积。这一类的锁一般也会对应用服务器造成后端压力，使得应用服务器也出现排队问题

* 另外一个原因是服务区突然遇到了大量查询请求的冲击，比如前端的memcached突然失效导致的查询风暴。 

#### 使用 SHOW PROCESSLIST

```
mysql -e 'SHOW PROCESSLIST\G' | grep State: | sort | uniq -c | sort -rn
```

可以看到线程的状态有:freeing items, end, cleaning up, logging slow query，大量的线程处于'freeing items'状态是出现了大量有问题查询的很明显的特征和指示

如果MySql服务器的版本较新，也可以直接查询INFOMATION_SCHEMA中的PROCESSLIST表；或者使用innotop工具以较高频率刷新。

* InnoDB内部的争用和脏块刷新，会导致线程堆积。
* 一个经典的例子是很多查询处于"Locked"状态，这是MyISAM的一个经典问题，它的表级锁，在写请求较多时，可能迅速导致服务器级别的线程堆积。


间歇性的实际案例有：

* 应用通过curl从一个运行得很慢的外部服务来获取汇率报价的数据
* memecached缓存中一些重要条目过期，导致大量的请求落到MySQL以重新生成缓存条目
* DNS查询偶尔会有超时现象
* 可以能是由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，MySQL的查询缓存有时候会导致服务有短暂的停顿。
* 当并发度超过某个阈值时，InnoDB的扩展性限制查询计划的优化需要很长的时间。

#### 使用查询日志
开启慢日志查询，并在全局级别设置long_query_time为0，并且确认所有的连接都采用了新的设置。或者使用Percona Server的一个特性，可以在不断开现有的连接的情况下动态地使设置强制生效。

如果由于某些原因，不能设置慢查询日志记录所有的查询，也可以通过tcpdump和pt-query-digest工具来模拟替代。

利用脚本根据MySQL每秒将当前时间写入日志中的柜式统计每秒的查询数量。

```
awk '/^# Time:/{print $3, $4, c;c=0}/^# User/{c++}' slow-query.log
```

问题诊断时，建议使用前两方法： SHOW STATUS 和 SHOW PROCESSLIST。这两种方法开销很低，而且可能通过简单的shell脚本或者反复执行的查询来交互式地收集数据。

#### 捕获诊断数据
在开始之前，需要搞清楚两件事：

* 一个可靠且实时的‘触发器’， 也就是能区分什么时候出问题的方法
* 一个收集诊断数据的工具。 

触发器要注意的问题：误报(false positive)或者 漏检(false negative)

```
mysql -e 'SHOW PROCESSLIST\G' | grep -c "State freeing items"
```

触发器的阈值很重要，既要足够高，以确保在正常时不会被触发；又不能太高，要确保问题发生时不会错过。

* Threads_connected正常时不会超过150，将阀值设置为200或300会更好
* Threads_running正常情况下并发度不超过10，当并发线程到15时可能会有少量堆积的线程，建议的阀值是20

ps-stalk可以配置监控的变量，阀值，检查的频率等。

我们需要一种工具来监控服务器。Percona Toolkit中的pt-stalk很特性，可以作为监控工具。

我们需要收集系统的状态，CPU利用率， 磁盘使用率和可用空间，ps的输出采样率，内存利用率，以及可以从MySQL获得的信息，如SHOW STATUS, SHOW PROCESSLIST 和 SHOW INNODA STATUS.

在GNU/Linux平台，可用于服务器内部诊断的一个重要工具是oprofile，也可以用strace剖析服务器的系统调用。

如果剖析查询，可以使用tcpdump。
对于堆栈跟踪，可以使用GDB注入： 先启动gdb，然后附加(attach)到mysqld进程上，将所有的线程的堆栈都转储出来。

查询或事务的行为可以显示是否是由于使用服务器的方式导致的问题：性能低下的SQL查询，使用不当的索引，设计糟糕的数据逻辑架构。

* 通过抓取TCP流量工或是SHOW PROCESSLIST输出，可以获取查询和事务的地方，从而知道用户对数据库进行了什么样的操作
* 通过服务器内部行为则可以清楚服务器是否有bug,或内部的性能和扩展性是否有问题。

iosstat查看io
vmstat查询memory

> 我们知道这个版本的InnoDB存在‘痴狂刷新’的问题（也叫检查点停顿），发生这样的情况是因为InnoDB没有按时间均匀分布刷新请求，而是隔一段时间突然请求一次强制检查点导致大量刷新操作。这种机制可能会导致InnoDB内部生严重的阻塞，导致所有的操作需要排队等待进入内核， 从而引发InnoDB上一层服务器产生堆积。可以查看SHOW STATUS的计数器，追踪一下Innodb_buffer_pool_pages_flushed的变化。

究竟是什么导致了性能低下：

* 资源被过度使用，余量已经不足以正常工作
* 资源没有被正确配置
* 资源已经损坏或者失灵

df -h查看磁盘使用情况
lsof 查看服务器打开的文件句柄

```
awk '
/mysqld.*tmp/ {
	total += $7;
}
/^Sun Mar 28/ && total {
	printf "%s %7.2f MB\n", $4, total/1024/1024;
	total = 0;
}' lsof.txt
'
```

##### 使用用USER_STATISTICS

```
show tables from information_schema like '%_statistics'
```

通过上面的查询可以了解到：

* 可以查找使用得最多的或者是使用用得最少的表和索引，通过读取次数或者更新次数，或者两者一起排序
* 可以查找出从未使用过的索引，可以考虑删除之
* 可以看看复制用户的CONNECTD_TIMET和BUSY_TIME,以确认复制是否会很难跟上主库的进度。 

##### 使用strace

```
strace -cfg $(pidof mysqldd)
```

* strace度量时使用的是实际时间
* oprofile度量时使用的是CPU周期
> 当I/O等待出现问题的时候，strace能将它们显示出来，因为它从诸如read或是pread64这样的系统调用开始计时，直到调用结束。但oprofile不会这样，因为I/O系统调用并不会真正消耗CPU周期，而只是等待I/O完成而已

## Schema与数据类型优化
### 选择优化的数据类型

* 更小的通常更好
	> 更小的数据类型通常更快，因为它们占用更少的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。
	
* 简单就好
	> 简单数据类型操作通常需要更少的CPU周期，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较整型比较更复杂。尽量使用MySQL内建的类型而不是字符串来存储日期和时间，另外应该用整型存储IP地址。
	
* 尽量避免NULL
	> 查询中包含NULL列，对MySQL来说更难优化，因为可为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也要特殊处理。当可为NULL的列被索引时，每个索引记录一个额外的字节，在MyISAM里甚至可能导致固定大小的索引变成可变大小的索引。
	> 当然也有例外，InnoDB使用单独的位（bit）来存储NULL值，所以对于稀疏数据有很好的效率，但这一点不适于MyISAM.


##### 整数类型

有整数(whole number)和实数(real number)

TINYINIT 8, SMALLINT 16, MEDIUMINT 24, INT 32, BIGNIT 64, 它们可以存储从-2^(N-1)到2^(N-1), N是存储空间的位数

##### 实数类型
浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储。DOUBLE占用8个字节，相比FLOAT有更高的精度各更大的范围。和和数一样，能选择的只是存储类型；MySQL作为内部浮点计算的类型。

可以考虑用BIGINT代替DECEMAL，将需要存储的数据根据小数的位数乘以相应的倍数。

##### 字符串类型
VARCHAR
> VARCHAR使用1或2个额外字节记录字符串的长度。如果列的最大长度小于或等于200个字节，则只使用1个字节表示；否则使用2个字节。例如采用latin1字符集，VARCAHR(10)需要使用11个字节的存储空,VARCHAR(1000)列则需要1002个字节，因为需要2个字节存储长度信息。

> VARCHAR	节省了空，对性能有帮助。但由于变长，在UPDATE时可能使行变得比原来长，这导致需要做额外的工作。不同的引擎处理方式不一样。MyISAM会将行折成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。

下面这些情况使用VARCHAR是合适的：

* 字符串列的最大长度比平均长度大很多
* 列的更新很少，所以碎片不是问题
* 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储

CHAR

* 适合存储很短的字符串
与 CHAR VARCHAR类似还有BINARY, VARBINARY,它们存储的是二进制字符串。
二进制比较的优势并不仅仅体现在大小写敏感上，MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数据进行比较。因此，二进制比较比字符串简单很多，所以也就更快。

---
BLOB 和 TEXT类型

BLOB TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储

字符类型：TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT

二进制类型: TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LOGNBLOB.

BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词

当BLOB, TEXT值太大时，InnoDB会使用专门的‘外部’存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然反在外部存储区域存储实际的值。

MySQL对BLOB TEXT的列进行排序与其他类型不同：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。或果只需要排序最前面一小部分字符，则可以减小max_sort_length配置，或者使用ORDER BY SUSTRING(column, length)

MySQL不能将BLOB, TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

ENUM

好处：

* MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存‘数字-字符串’映射关系的‘查找表’。
* 枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。可以在查询在使用FIELD()函数显示地指定排序顺序，来绕过个限制，但这会导致MySQL无法利用索引消除排序。

坏处

* 枚举不好的地方，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。
* 由于MySQL把每个枚举保存为整数，并且必须进行查找才能转换为字符串，所以枚举列有一些开销。

##### 日期和时间类型
DATATIME
> 存储从1001到9999年，精度为秒，把日期和时间封装成YYYYMMDDKKHHMMSS的整数中，与时区无关，例用8个字节存储空间

TIMESTAMP
> 保存从1970年1月1日午夜以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此其范围比DATATIME小，只能到1970到2038.MySQL提供到FROM_UNIXTIME()函数把Uinx时间戳转换成日期，UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。

> TIMESTAMP显示依赖于时区。其列默认为NOT NULL,这和其他数据类型不一样。 

除了特殊行为之外，通常应该尽量使用TIMESTAMP,因为它DATATIME空间效率更高。


BIT

可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。最大长度是64个位。

如果需要在一个bit的存储空间中存储一个true/false值，另一个方法是创建一个可以为空的char(0)列，该列可以保存空值（NULL）或者长度为0的字符串（空字符串）

SET

如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部是以一系列打包的位的集合来表示的。

优点：

* 有效利用存储空间
* 利用FIND_IN_SET(), FIELD()这样的函数，方便查询


缺点：

* 改变列的定义代价较高，需要ALTER TABLE

在整数列上进行按位操作

一种替代SET的方式是使用一个整数包装一系列的位。例如，可以把8个位包装到一个TINYINT中，并且按位操作使用。
好处是可以不使用ALTER TABLE改变字段代表的‘枚举’，缺点是查询语句难写，难理解

MySQL在内部使用整数存储ENUM, SET类型，然后在做比较操作时转换为字符串

例如

```
CREATE TABLE ac;(perms SET('CAN_READ', 'CAT_DELETE') NOT NULL);

INSERT INTO acl(perms) VALUES ('CAN_READ, CAN_DELETE');

SELECT perms FROM acl WHERE FIND_IN_SET('CAN_READ', perms);

```

若用整数来存储：

```
SET 	@CAN_READ := 1 << 0,
		@CAN_WRITE := 1 << 1,
	 	@CAN_DELETE := 1 << 2;
	 	
CREATE TABLE acl(perms TINYINT UNSIGNED NOT NULL DEFAULT 0);

INSERT INTO acl(perms) VALUES(@CAN_READ + @CAN_DELETE);

SELECT perms FROM acl WHERE perms & @CAN_READ;
```

#### MySQL schema设计中的陷阱

* 太多的列
* 太多关联
* 全能的枚举
* 变相的枚举
* 非此发明（Not Invent Here）的NULL: 不一定不有用NULL，特殊情况还是可以用的

#### 范式与反范式

* 在范式化数据库中，每个事实数据会出现并且只出现一次
* 在反范式化数据库中，信息是冗余的，可能会存储在多个地方

范式的优点与缺点：

* 范式化的更新操作通常比反范式化要快
* 当数据较好地范式化时，就只有很少或者没有重复的数据，所以只需要修改更少的数据
* 范式化表通常更小，可以更好地放在内存里，所以执行操作更快
* 很少有冗余的数据意味着检索列表数据时更少需要DISTINCT GROUP BY才能获取数据
* 范式化设计缺点是查询通常需要关联

反范式化的优点与缺点

* 数据在同一张表中，避免关联
* 数据更新需修改很多数据

混用范式化与反范式化

#### 缓存表与汇总表

```
CREATE TABEL msg_per_hr (
	hr DATATIME NOT NULL,
	cnt INT UNSIGNED NOT NULL,
	PRIMARY KEY (hr)
);

SELECT SUM(cnt) FROM msg_per_hr
WHERE hr BETWEEN
	CONCAT(LEFT(NOW(), 14), '00:00') - INTERVAL 23 HOUR
	AND CONCAT(LEFT(NOW(), 14), '00:00') 0 INTERVAL 1 HOUR;

SELECT COUNT(*) FROM message
WHERE posted >=  NOW() - INTERVAL 24 HOUR
	AND posted < CONCAT(LEFT(NOW(), 14), '00:00') - INTERVAL 23 HOUR;
	
SELECT COUNT(*) FROM message
WHERE posted >= CONCAT(LEFT(NOW(), 14), '00:00');

-----

DROP TABLE IF EXISTS my_summay_new, my_summary_old;
CREATE TABLE my_summary_new LIKE my_summary;
RENAME TABLE my_summay TO my_summay_old, my_summary_new TO my_summay;
```

#### 计数器表
如果在应用中保存计数器，则在更新计数器时可能碰到并发问题，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex），这会使得这些事务只能串行执行。可以将计数器保存在多行中，每次随机选择一条进行更新。

同样也可以每隔一段时间开始一个新的计数器。

如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到0号槽，并且删除所有其他的槽


#### 加快ALTER TABLE操作的速度

MySQL的ALTER TABLE操作的性能对大表来说是个大问题。

一般而言，大部分的ALTER TABLE操作将导致MySQL的服务中断，对于常见的场景，能使用的技巧有两种：

* 一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行交换
* 另外一种是‘影子拷贝’，其技巧是：用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。

不是所有ALTER TABLE操作都会做表重建，如有两种方法可以改变或删除一个列的默认值（一种方法很快，一种方法很慢）：

```
ALTER TABLE sakila.film MODIFY COLUMN rental_duration TINYINT(3) NOT NULL DEFAULT 5;
```

此操作会拷贝整张表到一张新表，甚至列的类型，大小各可否为NULL的属性都没有改变

```
ALTER TABLE sakila.film ALTER COLUMN rental_duration SET DEFAULT 5;
```

理论上，MySQL可以跳过创建新表的步骤，表的默认值实际在表的.frm文件中，可以直接修改这个文件而不需要改动表本身。此操作就可以直接修改.frm文件，所以非常的快。

另外，也可以通过交换.frm文件实现ALTER TABLE:

1. 创建一张有相同结构的空表，并进行所需要的修改（例如增加ENUM常量）
2. 执行FLUSH TABLES WITH READ LOCK.这将关闭所有正在使用的表，并且禁止任何表被打开
3. 交换.frm文件
4. 执行UNLOCK TABLES来释放每2步的读锁。

#### 快速创建MyISAM索引
为了高效地载入数据到MyISAM表中，常用的技巧是：先禁用索引，载入数据，然后重新启用索引。

```
ALTER TABLE test.load_data DISABLE KEYS;
---load data
ALTER TABLE test.load_data ENABLE KEYS;
``` 

不幸地是，这个办法对唯一索引无效，因为DISABLE KEYS只对非唯一索引有效。

SCHEMA设计总结：

* 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表设计（很多的意思是介于有点多和非常多之间）
* 使用小而简单的合适数据类型，除非真实数据模型有确切的需求，否则应该尽可能地避免使用NULL值
* 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
* 注意可变长字符串，其在临时表和排序可能导致悲观的按最大长度分配内存
* 尽量使用整型定义标识列
* 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度
* 小心使用ENUM SET。虽然他们使用起来很方便，但是不要滥用，否则有时候会变成陷阱，最好避免使用BIT

## 第五章 创建高性能的索引
### 5.1索引基础
索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。

### 5.1.1索引的类型
MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据进行存储；MyISAM索引通过数据物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

B-Tree通常意味着所有有值都是按顺序存储的，并且每一个叶子页到根的距离相同

B-Tree索引适用于全健值，键值范围或键前缀查找：

* 全值匹配

	> 全值匹配指的是和索引中的所有列进行匹配
* 匹配最左前缀
	
* 匹配列前缀

	> 也可以只匹配某一列的值的开头部分	
* 匹配范围值

	> 精确匹配某一列并范围匹配另一列
* 只访问索引的查询

B-Tree索引的一些限制

* 如果不是按照索引的最左列开始查找，则无法使用索引
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。如Like


#### 哈希索引
哈希索引(has index)基于于哈希表实现，只有精确匹配索引所有列的查询才有效；如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。

因为哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。

但哈希索引也有限制：

* 哈希索引只包括哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读到行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
* 哈希索引只支持等值查询，包括=, IN(), <=>，也不支持任何范围查询
* 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的哈希列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的指针，逐行进行比较，直到找到所有符合条件的行
* 如果哈希冲突很多的话，一些索引维护操作的代价也会很高

因这些限制，哈希索引只适用一某些特殊的场合。而一旦适合哈希索引，则它带来的性能提升将非常显著

#### 空间数据索引(R-Tree)
MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据，查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的想着函数如MBRCONTAINS()等来维护数据

#### 全文索引
全文索引是一种特殊索引，它查找是文本中的关键词，而不是直接比较索引中的值。需可注意的细节，如停用词，词干，复数，布乐搜索等

### 5.2索引的优点

* 索引大大减小了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序各临时表
* 索引可以将随机I/O变成顺序I/O

三星索引：

* 索引将相关的记录放到一起则获一颗性
* 索引中的数据顺序各查找中的排序顺序一致则获两颗星
* 索引中的列包含了查询中需要的全部列则获得三星

### 5.3高性能的索引策略
#### 5.3.1独立的列
#### 5.3.2前缀索引各索引选择性
索引很长的字符列，会让索引变大且慢，可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但同时会降低索引的选择性

索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间，索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQl查找时过滤掉更多的行。唯一索引的选择性就是1，这是最好的索引选择性，性能也是最好的。

对于BLOB TEXT或是很长的VARCHA类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

反缀索引（suffix index）要以通过反转字符，触发器等技术手段实现。

#### 5.3.3多列索引
索引合并策略会有一定的优化，但也说明索引建得不好：

* 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
* 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量的CPU和内存资源在算法的缓存，排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候
* 更重要的是，优化器不会把这些计算到‘查询成本（cost）’中，优化器只关心随机页面读取。会消耗更多的CPU和内存资源，这样会影响查询的并发性。

可以通过optimizer_switch来关闭索引合并。也可以用IGNORE INDEX来提示让优化器忽略掉某些索引

#### 5.3.4选择合适的索引顺序
索引的顺序适用于B-Tree，哈希索引或是其他类型的索引并不会像B-Tree一样按顺序存储数据
